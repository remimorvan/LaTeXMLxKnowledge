# /=====================================================================\ #
# |  knowledge.sty                                                      | #
# | Implementation for LaTeXML                                          | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | RÃ©mi Morvan <remi@morvan.xyz>                               #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #
package LaTeXML::Package::Pool;
use strict;
use warnings;
use LaTeXML::Package;

# ---
# Defines functions to handle all knowledges
# ---
sub breakupDirectives {
	my ($directives) = @_;
	# $directives is a string, containing a list of directives
	# of the form `key=value` (e.g. `url="https://wikipedia.org"`)
	# or of the form `key` (e.g. `notion`, `synonym`).
	# We breakit up into a hashable.
	my %directivesHash;
	foreach my $dir (split(",", $directives)) {
		if ($dir =~ /^(.*)=(.*)$/) {
			$directivesHash{$1} = $2;
		} else {
      $directivesHash{$dir} = 1;
    }
	}
	return \%directivesHash;
}

sub getDirective {
  # Checks if the a directive was given for a knowledge.
  # Returns either a boolean or a value (e.g. for `url`).
  my ($kl, $dir) = @_;
  if (defined LookupMapping("KL:knowledges", $kl)->{$dir}) {
    return LookupMapping("KL:knowledges", $kl)->{$dir};
  }
  return 0; 
}

sub yieldsInternalHyperlink {
  my ($kl) = @_;
  return getDirective($kl, "notion") || getDirective($kl, "link");
}

sub getRootNotion {
  # Given a knowledge that produces an internal hyperlink, get
  # its root knowledge.
  my ($kl) = @_;
  if (getDirective($kl, "notion")) {
    return $kl;
  }
  my $parent = getDirective($kl, "link");
  return getRootNotion($parent);
}

# Store the directives in a global dict 'KL:knowledges'
DefPrimitive('\knowledge{}{}',
  sub {
    my ($stomach, $source, $directives) = @_;
    AssignMapping('KL:knowledges', $source->toString(), breakupDirectives($directives->toString()));
    return undef;
});

DefConstructor('\kl[]{}',
    "<ltx:ref class='kl' labelref='KLTEMP:#kl'>#2</ltx:ref>",
    mode=>'text',
    properties=> sub {
      (kl => ($_[1] ? $_[1] : $_[2]))
});

# There was no reasonable element for \intro that supported the attribute labels,
# so we added this attribute to the anchor element.
# https://math.nist.gov/~BMiller/LaTeXML/manual/schema/LaTeXML-common/#I1.ix14.I14.ix2.p1
DefConstructor('\intro[]{}',
    "<ltx:anchor class='klintro' labels='KLTEMP:#kl'>#2</ltx:anchor>",
    mode=>'text',
    properties=> sub {
      (kl => ($_[1] ? $_[1] : $_[2]))
});

DefRewrite(
  select => ["descendant-or-self::ltx:anchor"],
  match => sub {
    my ($doc, $anchor) = @_;
    my $label = $anchor->getAttribute("labels");
    if ($label =~ /^KLTEMP:(.*)$/) {
      $anchor->setAttribute("labels", "KL:" . getRootNotion($1));
    }
  }
);

DefRewrite(
  select => ["descendant-or-self::ltx:ref"],
  match => sub {
    my ($doc, $ref) = @_;
    my $label = $ref->getAttribute("labelref");
    if ($label =~ /^KLTEMP:(.*)$/) {
      $ref->setAttribute("labelref", "KL:" . getRootNotion($1));
    }
  }
);



# print "\n[KL]", LookupMapping('KL:knowledges', 'groups'), "\n";

# DefConstructor('\knowledge{}{}',
#   "<ltx:rdf about='#1' resource='#target' property='KL:#prop'/>",
#   mode=>'text',
#   properties=> sub {
#     print @knowledges, "\n";
#     my $directive = $_[2];
#     if ($directive->toString() =~ /^(.+)=(.+)$/) {
#       # If the directive contains '=', as in 'link=monoid',
#       # then we split the property (LHS) from the target (RHS).
#       return (prop => $1, target => $2);
#     }
#     return (prop => $directive);
# });

1; 