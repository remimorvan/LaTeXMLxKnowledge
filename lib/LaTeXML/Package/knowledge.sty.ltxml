# /=====================================================================\ #
# |  knowledge.sty                                                      | #
# | Implementation for LaTeXML                                          | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | RÃ©mi Morvan <remi@morvan.xyz>                               #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #
package LaTeXML::Package::Pool;
use strict;
use warnings;
use 5.010;
use LaTeXML::Package;

# ---
# Prefix of knowledge labels used in the xml document
# ---
my $prefixLabel = "KL:";
my $prefixLabelTemp = "KLTEMP:";

# ---
# Names of values/mapping used to store information obtained while scanning .tex document
# ---
# Hash of all directives
my $definedDirectives = "KL:definedDirectives";
# Name of last knowledge that was defined
my $lastKnowledge = "KL:lastKnowledge";

# ---
# Defines functions to handle all knowledges
# ---

sub processDirectives {
  # Given a pair (key, value) defining a new directive, updates the hashref
  # $refDirectives accordingly.
  my ($key, $value, $refDirectives) = @_;
  my $processDirectives_ = {
    synonym => sub { $refDirectives->{"link"} = LookupValue($lastKnowledge); },
    default => sub {
      # Remove surronding double quotes in value (if there are some)
      $refDirectives->{$key} = ($value =~ /^"(.*)"$/) ? $1 : $value;
    }
  };
  ($processDirectives_->{$key} || $processDirectives_->{"default"})->();
}

sub breakupDirectives {
	my ($directivesString) = @_;
	# $directives is a string, containing a list of directives
	# of the form `key=value` (e.g. `url="https://wikipedia.org"`)
	# or of the form `key` (e.g. `notion`, `synonym`).
	# We break it into a hashable.
	my %directivesHash;
	foreach my $dir (split(",", $directivesString)) {
		if ($dir =~ /^(.*)=(.*)$/) {
      processDirectives($1, $2, \%directivesHash);
		} else {
      processDirectives($dir, 1, \%directivesHash);
    }
	}
	return \%directivesHash;
}

sub getDirective {
  # Checks if the a directive was given for a knowledge.
  # Returns either a boolean or a value (e.g. for `url`).
  my ($kl, $dir) = @_;
  if (defined LookupMapping($definedDirectives, $kl)->{$dir}) {
    return LookupMapping($definedDirectives, $kl)->{$dir};
  }
  return 0; 
}

sub yieldsInternalHyperlink {
  my ($kl) = @_;
  return getDirective($kl, "notion") || getDirective($kl, "link");
}

sub getRootNotion {
  # Given a knowledge that produces an internal hyperlink, get
  # its root knowledge.
  my ($kl) = @_;
  if (getDirective($kl, "notion")) {
    return $kl;
  }
  my $parent = getDirective($kl, "link");
  return getRootNotion($parent);
}

# ---
# Defines primitives and constructors
# ---

# Store the directives in a global dict called $definedDirectives
DefPrimitive('\knowledge{}{}',
  sub {
    my ($stomach, $source, $directives) = @_;
    AssignMapping($definedDirectives, $source->toString(), breakupDirectives($directives->toString()));
    AssignValue($lastKnowledge, $source->toString());
    return undef;
});

DefConstructor('\kl[]{}',
    "<ltx:ref class='kl' labelref='KLTEMP:#kl'>#2</ltx:ref>",
    mode=>'text',
    properties=> sub {
      (kl => ($_[1] ? $_[1] : $_[2]))
});

# There was no reasonable element for \intro that supported the attribute labels,
# so we added this attribute to the anchor element.
# https://math.nist.gov/~BMiller/LaTeXML/manual/schema/LaTeXML-common/#I1.ix14.I14.ix2.p1
DefConstructor('\intro[]{}',
    "<ltx:anchor class='klintro' labels='KLTEMP:#kl'>#2</ltx:anchor>",
    mode=>'text',
    properties=> sub {
      (kl => ($_[1] ? $_[1] : $_[2]))
});

# ---
# Rewrite temporary labels by using directives definitions
# ---

DefRewrite(
  select => ["descendant-or-self::ltx:anchor"],
  match => sub {
    my ($doc, $anchor) = @_;
    my $label = $anchor->getAttribute("labels");
    if ($label =~ /^KLTEMP:(.*)$/) {
      $anchor->setAttribute("labels", "KL:" . getRootNotion($1));
    }
  }
);

DefRewrite(
  select => ["descendant-or-self::ltx:ref"],
  match => sub {
    my ($doc, $ref) = @_;
    my $label = $ref->getAttribute("labelref");
    if ($label =~ /^KLTEMP:(.*)$/) {
      $ref->setAttribute("labelref", "KL:" . getRootNotion($1));
    }
  }
);

1; 