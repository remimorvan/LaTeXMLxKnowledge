# /=====================================================================\ #
# |  knowledge.sty                                                      | #
# | Implementation for LaTeXML  -  https://ctan.org/pkg/knowledge       | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | RÃ©mi Morvan <remi@morvan.xyz>                               #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #
package LaTeXML::Package::Pool;
use strict;
use warnings;
use LaTeXML::Package;
use feature 'state';

# ---
# Prefix of knowledge labels used in the xml document
# ---
my $prefixLabel = "KL:";
my $prefixLabelTemp = "KLTEMP:";
my $dumbLabel = "KLUNIQUE:dumbAPlabel";

# ---
# Names of values/mapping used to store information obtained while scanning .tex document
# ---
# Hash of all directives
my $definedDirectives = "KL:definedDirectives";
# Name of last knowledge that was defined
my $lastKnowledge = "KL:lastKnowledge";

# ---
# Defines functions to handle all knowledges
# ---

sub processDirectives {
  # Given a pair (key, value) defining a new directive, updates the hashref
  # $refDirectives accordingly.
  my ($key, $value, $refDirectives) = @_;
  my $processDirectives_ = {
    synonym => sub { $refDirectives->{"link"} = LookupValue($lastKnowledge); },
    default => sub {
      # Remove surronding double braces in value (if there are some)
      $refDirectives->{$key} = ($value =~ /^{(.*)}$/) ? $1 : $value;
    }
  };
  ($processDirectives_->{$key} || $processDirectives_->{"default"})->();
}

sub breakupDirectives {
	my ($directivesString) = @_;
	# $directives is a string, containing a list of directives
	# of the form `key=value` (e.g. `url={https://wikipedia.org}`)
	# or of the form `key` (e.g. `notion`, `synonym`).
	# We break it into a hashable.
	my %directivesHash;
	foreach my $dir (split(",", $directivesString)) {
		if ($dir =~ /^(.*)=(.*)$/) {
      processDirectives($1, $2, \%directivesHash);
		} else {
      processDirectives($dir, 1, \%directivesHash);
    }
	}
	return \%directivesHash;
}

sub isKnowledgeDefined {
  my ($kl) = @_;
  return defined LookupMapping($definedDirectives, $kl);
}

sub getDirective {
  # Checks if the a directive was given for a knowledge.
  # Returns either a boolean or a value (e.g. for `url`).
  my ($kl, $dir) = @_;
  if (isKnowledgeDefined($kl) && defined LookupMapping($definedDirectives, $kl)->{$dir}) {
    return LookupMapping($definedDirectives, $kl)->{$dir};
  }
  return 0; 
}

sub getRootNotion {
  # Given a knowledge, get its root knowledge, or 0 if it doesn't exist.
  my ($kl) = @_;
  if (getDirective($kl, "notion")) {
    return $kl;
  }
  if (my $parent = getDirective($kl, "link")) {
    return getRootNotion($parent);
  }
  return 0;
}

sub getUrl {
  # Given a knowledge, returns its url if it has some, and zero otherwise.
  my ($kl) = @_;
  if (my $url = getDirective($kl, "url")) {
    return $url;
  }
  return 0;
}

# ---
# Defines primitives and constructors
# ---

# Store the directives in a global dict called $definedDirectives
DefPrimitive('\knowledge{}{}',
  sub {
    my ($stomach, $source, $directives) = @_;
    AssignMapping($definedDirectives, $source->toString(), breakupDirectives($directives->toString()));
    AssignValue($lastKnowledge, $source->toString());
    return undef;
});

DefConstructor('\kl[]{}',
    "<ltx:ref class='kl' labelref='$prefixLabelTemp#kl'>#2</ltx:ref>",
    properties=> sub {
      (kl => ($_[1] ? $_[1] : $_[2]))
});

# We add a dumb (temporary) label to the anchor to force LaTeXML
# to assign it an xml:id. Its final labels will be defined during Rewriting.
DefConstructor('\AP',
    "<ltx:anchor class='klAP' labels='$dumbLabel'/>"
);

# There was no reasonable element for \intro that supported the attribute labels,
# so we added this attribute to the anchor element.
# https://math.nist.gov/~BMiller/LaTeXML/manual/schema/LaTeXML-common/#I1.ix14.I14.ix2.p1
DefConstructor('\intro[]{}',
    "<ltx:anchor class='klintro' labels='$prefixLabelTemp#kl'>#2</ltx:anchor>",
    properties=> sub {
      (kl => ($_[1] ? $_[1] : $_[2]))
});

# ---
# Rewrite temporary labels by using directives definitions
# ---

sub findLastAnchor {
  # Returns a hashref that maps any \intro
  # (or rather its XML representation as an anchor tag of class klintro)
  # to the lattest preceding occurence of an anchor (in fact, any anchor or section node
  # with an xml:id attribute: this includes \AP, but also sections).
  # This is hash is cached.
  my ($doc) = @_;
  state $mappingToLastAnchor = {};
  unless (%$mappingToLastAnchor) {
    state $lastAnchor = 0;
    sub dfs {
      my ($node) = @_;
      if (
        $node->nodeName() eq 'anchor'
        && $node->hasAttribute('class')
        && $node->getAttribute('class') eq 'klintro'
        && $lastAnchor != 0
      ) {
        $mappingToLastAnchor->{$node} = $lastAnchor;
      } elsif (
        ($node->nodeName() eq 'anchor'
          || $node->nodeName() eq 'section')
        && $node->hasAttribute('xml:id')
      ) {
        $lastAnchor = $node;
      }
      for my $child ($node->getChildrenByTagName('*')) {
        dfs($child);
      }
    }
    dfs($doc->documentElement());
  }
  return $mappingToLastAnchor;
}

# Whenever we find an anchor tag created by an \intro
# (i.e. of class klintro and with label(s)), we:
# 1. Move the labels to the lattest preceding occurence of 
#     an \AP (represented by an anchor of class klAP), or sectionning.
# 2. Change the anchor tag into a `text` tag.
DefRewrite(
  xpath => "//ltx:anchor[\@class = 'klintro'][starts-with(\@labels, '$prefixLabelTemp')]",
  match => sub {
    my ($doc, $intro) = @_;
    if ($intro->getAttribute("labels") =~ /^$prefixLabelTemp(.*)$/) {
      if (isKnowledgeDefined($1)) {
        my $mappingToLastAnchor = findLastAnchor($doc);
        # Move labels to the last anchor (any node with an xml:id attribute).
        if (my $anchor = $mappingToLastAnchor->{$intro}) {
          my $newLabel = "";
          if ($anchor->hasAttribute("labels")) {
            $newLabel .= $anchor->getAttribute("labels") . " ";
          }
          $newLabel .= $prefixLabel . getRootNotion($1);
          $anchor->setAttribute("labels", $newLabel);
        }
      }
      # Create new text tag
      $intro->setNodeName("text");
      $intro->removeAttribute("labels");
      $intro->removeAttribute("xml:id");
      if (!isKnowledgeDefined($1)) {
        $intro->setAttribute('class', 'klintroundefined');
      }
    }
  }
);

DefRewrite(
  xpath => "//ltx:anchor[\@class = 'klAP']",
  match => sub {
    my ($doc, $anchor) = @_;
    if ($anchor->hasAttribute("labels")) {
      # If there are no other labels, remove the node.
      # Otherwise, only remove the temporary label.
      if ($anchor->getAttribute("labels") eq $dumbLabel) {
        $anchor->unbindNode();
        # $anchor->setAttribute("labels", "");
      } elsif ($anchor->getAttribute("labels") =~ /^$dumbLabel (.*)$/) {
        $anchor->setAttribute("labels", $1);
      }
    }
  } 
);

sub rewriteKnowledge {
  my ($ref, $kl) = @_;
  if (my $rootkl = getRootNotion($kl)) {
    $ref->setAttribute("labelref", $prefixLabel . $rootkl);
  } elsif (my $url = getUrl($kl)) {
    $ref->removeAttribute("labelref");
    $ref->setAttribute("href", $url);
  }
}

DefRewrite(
  xpath => "//ltx:ref[\@class = 'kl'][starts-with(\@labelref, '$prefixLabelTemp')]",
  match => sub {
    my ($doc, $ref) = @_;
    if ($ref->getAttribute("labelref") =~ /^$prefixLabelTemp(.*)$/) {
      rewriteKnowledge($ref, $1);
    }
  }
);

1; 