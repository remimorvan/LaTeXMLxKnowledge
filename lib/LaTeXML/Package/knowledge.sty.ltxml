# /=====================================================================\ #
# |  knowledge.sty                                                      | #
# | Implementation for LaTeXML  -  https://ctan.org/pkg/knowledge       | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | RÃ©mi Morvan <remi@morvan.xyz>                               #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #
package LaTeXML::Package::Pool;
use strict;
use warnings;
use LaTeXML::Package;
use feature 'state';

# ---
# Prefix of knowledge labels used in the xml document
# ---
my $prefixLabel = "kl:";

# ---
# Names of values/mapping used to store information obtained while scanning .tex document
# ---
my $definedDirectives = "kl:definedDirectives"; # Hash of all directives
my $lastKnowledge = "kl:lastKnowledge"; # Name of last knowledge that was defined
my $lastAP = "kl:lastAP"; # Pointer to last AP
my $lastAPsubstitute = "kl:lastAPsubstitute"; # Pointer to last AP
my $APindex = "kl:APindex"; # Number of AP

# ---
# Defines functions to handle all knowledges
# ---

sub processDirectives {
  # Given a pair (key, value) defining a new directive, updates the hashref
  # $refDirectives accordingly.
  my ($key, $value, $refDirectives) = @_;
  my $processDirectives_ = {
    synonym => sub { $refDirectives->{"link"} = LookupValue($lastKnowledge); },
    default => sub {
      # Remove surronding double braces in value (if there are some)
      $refDirectives->{$key} = ($value =~ /^{(.*)}$/) ? $1 : $value;
    }
  };
  ($processDirectives_->{$key} || $processDirectives_->{"default"})->();
}

sub breakupDirectives {
	my ($directivesString) = @_;
	# $directives is a string, containing a list of directives
	# of the form `key=value` (e.g. `url={https://wikipedia.org}`)
	# or of the form `key` (e.g. `notion`, `synonym`).
	# We break it into a hashable.
	my %directivesHash;
	foreach my $dir (split(",", $directivesString)) {
		if ($dir =~ /^(.*)=(.*)$/) {
      processDirectives($1, $2, \%directivesHash);
		} else {
      processDirectives($dir, 1, \%directivesHash);
    }
	}
	return \%directivesHash;
}

sub isKnowledgeDefined {
  my ($kl) = @_;
  return defined LookupMapping($definedDirectives, $kl);
}

sub getDirective {
  # Checks if the a directive was given for a knowledge.
  # Returns either a boolean or a value (e.g. for `url`).
  my ($kl, $dir) = @_;
  if (isKnowledgeDefined($kl) && defined LookupMapping($definedDirectives, $kl)->{$dir}) {
    return LookupMapping($definedDirectives, $kl)->{$dir};
  }
  return 0; 
}

sub getRootNotion {
  # Given a knowledge, get its root knowledge, or 0 if it doesn't exist.
  my ($kl) = @_;
  if (getDirective($kl, "notion")) {
    return $kl;
  }
  if (my $parent = getDirective($kl, "link")) {
    return getRootNotion($parent);
  }
  return 0;
}

sub getUrl {
  # Given a knowledge, returns its url if it has some, and zero otherwise.
  my ($kl) = @_;
  if (my $url = getDirective($kl, "url")) {
    return $url;
  }
  return 0;
}

# ---
# Defines primitives and constructors
# ---

# Store the directives in a global dict called $definedDirectives
DefPrimitive('\knowledge{}{}',
  sub {
    my ($stomach, $source, $directives) = @_;
    AssignMapping($definedDirectives, $source->toString(), breakupDirectives($directives->toString()));
    AssignValue($lastKnowledge, $source->toString());
    return undef;
});

# Labels of the anchor will be added when constructing \intro.
DefConstructor('\AP',
  sub {
    my $document = $_[0];
    unless (LookupValue($APindex)) {
      AssignValue($APindex, 0);
    }
    my $APindexValue = LookupValue($APindex);
    AssignValue($APindex, $APindexValue + 1);
    $document->openElement("ltx:anchor", class => "klAP", labels => "klAP:" . $APindexValue);
    AssignValue($lastAP, $document->getNode());
    $document->closeElement("ltx:anchor");
  },
  afterConstruct => sub {
    my $document = $_[0];
  }
);

sub parse_kl_or_intro {
  my ($document, $scope, $kl, $text) = @_;
  $kl = ($kl ? $kl->toString() : $text->toString()) . ($scope ? '@' . $scope->toString() : '');
  (kl => $kl, text => $text->toString())
}

DefConstructor('\kl OptionalBalancedParen []{}',
  sub {
    my $document = $_[0];
    my %props = parse_kl_or_intro(@_);
    my $kl = $props{"kl"};
    my $text = $props{"text"};
    my %args = ();
    if (my $rootkl = getRootNotion($kl)) {
      %args = ("labelref" => $prefixLabel . $rootkl, class => "kl");
    } elsif (my $url = getUrl($kl)) {
      %args = ("href" => $url, class => "kl");
    } else {
      %args = (class => "klundefined")
    }
    $document->openElement("ltx:ref", %args);
    $document->absorb($text);
    $document->closeElement("ltx:ref");
  }
);

sub getLastAP {
  my ($document) = @_;
  # If some AP has already been defined, we return it.
  # Otherwise, we look for the last tag with a `xml:id` attribute.
  # Typically this should correspond to the parent paragraph.
  if (my $anchor = LookupValue($lastAP)) {
    return $anchor;
  } else {
    AssignValue($lastAPsubstitute, $document->documentElement());
    sub dfs {
      my ($node) = @_;
      if ($node->hasAttribute('labels')) {
        AssignValue($lastAPsubstitute, $node);
      }
      for my $child ($node->getChildrenByTagName('*')) {
        dfs($child);
      }
    }
    dfs($document->documentElement());
    return LookupValue($lastAPsubstitute);
  }
}

# There was no reasonable element for \intro that supported the attribute labels,
# so we added this attribute to the anchor element.
# https://math.nist.gov/~BMiller/LaTeXML/manual/schema/LaTeXML-common/#I1.ix14.I14.ix2.p1
DefConstructor('\intro OptionalBalancedParen []{}',
  sub {
    my ($document, $scope, $kl, $text) = @_;
    my %props = parse_kl_or_intro(@_);
    my $labelref = $prefixLabel . ($props{"kl"});
    $text = $props{"text"};
    my $class;
    if (isKnowledgeDefined($props{"kl"})) {
      # Move labels to the last anchor
      my $anchor = getLastAP($document);
      # We only append the new label if the anchor has an xml:id
      # This prevent e.g. adding a labels attribute to a tag that shouldn't have one.
      if ($anchor->hasAttribute('labels')) {
        my $newLabel = $anchor->getAttribute("labels") . " ";
        $newLabel .= $prefixLabel . getRootNotion($props{"kl"});
        $anchor->setAttribute("labels", $newLabel);
      } else {
        Note("Warning (knowledge): intro of knowledge `$props{'kl'}` is ignored, there is no preceeding anchor point (\\AP).");
      }
      $class = "klintro";
    } else {
      $class = "klintroundefined";
    }
    $document->openElement("ltx:text", labels => $labelref, class => $class);
    $document->absorb($text);
    $document->closeElement("ltx:text");
  }
);

1; 