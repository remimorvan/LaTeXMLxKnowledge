# /=====================================================================\ #
# |  knowledge.sty                                                      | #
# | Implementation for LaTeXML                                          | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | RÃ©mi Morvan <remi@morvan.xyz>                               #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #
package LaTeXML::Package::Pool;
use strict;
use warnings;
use LaTeXML::Package;
use feature 'state';

# ---
# Prefix of knowledge labels used in the xml document
# ---
my $prefixLabel = "KL:";
my $prefixLabelTemp = "KLTEMP:";

# ---
# Names of values/mapping used to store information obtained while scanning .tex document
# ---
# Hash of all directives
my $definedDirectives = "KL:definedDirectives";
# Name of last knowledge that was defined
my $lastKnowledge = "KL:lastKnowledge";

# ---
# Defines functions to handle all knowledges
# ---

sub processDirectives {
  # Given a pair (key, value) defining a new directive, updates the hashref
  # $refDirectives accordingly.
  my ($key, $value, $refDirectives) = @_;
  my $processDirectives_ = {
    synonym => sub { $refDirectives->{"link"} = LookupValue($lastKnowledge); },
    default => sub {
      # Remove surronding double quotes in value (if there are some)
      $refDirectives->{$key} = ($value =~ /^"(.*)"$/) ? $1 : $value;
    }
  };
  ($processDirectives_->{$key} || $processDirectives_->{"default"})->();
}

sub breakupDirectives {
	my ($directivesString) = @_;
	# $directives is a string, containing a list of directives
	# of the form `key=value` (e.g. `url="https://wikipedia.org"`)
	# or of the form `key` (e.g. `notion`, `synonym`).
	# We break it into a hashable.
	my %directivesHash;
	foreach my $dir (split(",", $directivesString)) {
		if ($dir =~ /^(.*)=(.*)$/) {
      processDirectives($1, $2, \%directivesHash);
		} else {
      processDirectives($dir, 1, \%directivesHash);
    }
	}
	return \%directivesHash;
}

sub getDirective {
  # Checks if the a directive was given for a knowledge.
  # Returns either a boolean or a value (e.g. for `url`).
  my ($kl, $dir) = @_;
  if (defined LookupMapping($definedDirectives, $kl)->{$dir}) {
    return LookupMapping($definedDirectives, $kl)->{$dir};
  }
  return 0; 
}

sub yieldsInternalHyperlink {
  my ($kl) = @_;
  return getDirective($kl, "notion") || getDirective($kl, "link");
}

sub getRootNotion {
  # Given a knowledge that produces an internal hyperlink, get
  # its root knowledge.
  my ($kl) = @_;
  if (getDirective($kl, "notion")) {
    return $kl;
  }
  my $parent = getDirective($kl, "link");
  return getRootNotion($parent);
}

# ---
# Defines primitives and constructors
# ---

# Store the directives in a global dict called $definedDirectives
DefPrimitive('\knowledge{}{}',
  sub {
    my ($stomach, $source, $directives) = @_;
    AssignMapping($definedDirectives, $source->toString(), breakupDirectives($directives->toString()));
    AssignValue($lastKnowledge, $source->toString());
    return undef;
});

DefConstructor('\kl[]{}',
    "<ltx:ref class='kl' labelref='$prefixLabelTemp#kl'>#2</ltx:ref>",
    mode=>'text',
    properties=> sub {
      (kl => ($_[1] ? $_[1] : $_[2]))
});

DefConstructor('\AP',
    "<ltx:anchor class='klAP'/>",
    mode=>'text'
);

# There was no reasonable element for \intro that supported the attribute labels,
# so we added this attribute to the anchor element.
# https://math.nist.gov/~BMiller/LaTeXML/manual/schema/LaTeXML-common/#I1.ix14.I14.ix2.p1
DefConstructor('\intro[]{}',
    "<ltx:anchor class='klintro' labels='$prefixLabelTemp#kl'>#2</ltx:anchor>",
    mode=>'text',
    properties=> sub {
      (kl => ($_[1] ? $_[1] : $_[2]))
});

# ---
# Rewrite temporary labels by using directives definitions
# ---

sub findLastAnchorPoints {
  # Returns a hashref that maps any \intro
  # (or rather its XML representation as an anchor tag of class klintro)
  # to the lattest preceding occurence of 
  # an \AP (represented by an anchor of class klAP), or sectionning tag.
  # TODO: This is cached.
  my ($doc) = @_;
  state $mappingToLastAnchorPoint = {};
  unless (%$mappingToLastAnchorPoint) {
    state $lastAnchorPoint = $doc->documentElement();
    sub dfs {
      my ($node) = @_;
      if ($node->nodeName() eq 'anchor' && $node->hasAttribute('class')) {
        if ($node->getAttribute('class') eq 'klAP') {
          $lastAnchorPoint = $node;
        }
        if ($node->getAttribute('class') eq 'klintro') {
          $mappingToLastAnchorPoint->{$node} = $lastAnchorPoint;
        }
      }
      for my $child ($node->getChildrenByTagName('*')) {
        dfs($child);
      }
    }
    dfs($doc->documentElement());
  }
  return $mappingToLastAnchorPoint;
}

# Whenever we find an anchor tag created by an \intro
# (i.e. of class klintro and with label(s)), we:
# 1. Move the labels to the lattest preceding occurence of 
#     an \AP (represented by an anchor of class klAP), or sectionning.
# 2. Change the anchor tag into a `text` tag.
DefRewrite(
  xpath => "//ltx:anchor[\@class = 'klintro'][starts-with(\@labels, '$prefixLabelTemp')]",
  match => sub {
    my ($doc, $intro) = @_;
    if ($intro->getAttribute("labels") =~ /^$prefixLabelTemp(.*)$/) {
      my $mappingToLastAnchorPoint = findLastAnchorPoints($doc);
      my $anchorPoint = $mappingToLastAnchorPoint->{$intro};
      my $newLabel = (
        ($anchorPoint->hasAttribute("labels"))
        ? $anchorPoint->getAttribute("labels") . " "
        : ""
      ) . ($prefixLabel . getRootNotion($1));
      $anchorPoint->setAttribute("labels", $newLabel);
      # Create new text tag
      $intro->setNodeName("text");
      $intro->removeAttribute("labels");
      $intro->removeAttribute("xml:id");
    }
  }
);

DefRewrite(
  xpath => "//ltx:ref[\@class = 'kl'][starts-with(\@labelref, '$prefixLabelTemp')]",
  match => sub {
    my ($doc, $ref) = @_;
    if ($ref->getAttribute("labelref") =~ /^$prefixLabelTemp(.*)$/) {
      my $newLabel = $prefixLabel . getRootNotion($1);
      $ref->setAttribute("labelref", $newLabel);
    }
  }
);

1; 