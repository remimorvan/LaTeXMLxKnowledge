# /=====================================================================\ #
# |  knowledge.sty                                                      | #
# | Implementation for LaTeXML  -  https://ctan.org/pkg/knowledge       | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | RÃ©mi Morvan <remi@morvan.xyz>                               #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #
package LaTeXML::Package::Pool;
use List::Util(first);
use strict;
use warnings;
use LaTeXML::Package;

# ---
# Prefix of knowledge labels used in the xml document
# ---
my $prefixLabel = "kl:";

# ---
# Names of values/mapping used to store information obtained while scanning .tex document
# ---
my $definedKnowledges = "kl:definedKnowledges"; # Hash of all knowledges
my $lastKnowledge = "kl:lastKnowledge"; # Name of last knowledge that was defined
my $lastAP = "kl:lastAP"; # Pointer to last AP
my $lastAPsubstitute = "kl:lastAPsubstitute"; # Pointer to last AP
my $APindex = "kl:APindex"; # Number of AP
my $klOption = "kl:option"; # Hash of options

# Note that is displayed only if document has the option "latexmlverbose"
sub OptionalNote {
  Note(@_) if LookupMapping($klOption, "latexmlverbose");
}

# ---
# Command \knowledgeconfigure & option handlers
# ---

sub rememberOption {
  my ($option, $val) = @_;
  AssignMapping($klOption, $option, $val, 'global');
}
sub getOption {
  my ($option) = @_;
  return LookupMapping($klOption, $option)
}
my %processConfigure = (
  "quotation" => sub {AssignCatcode('"' => CC_ACTIVE);},
  "notion" => sub {},
  "latexmlverbose" => sub {},
);

DefPrimitive('\knowledgeconfigure{}',
  sub {
    my ($stomach, $arg) = @_;
    my @options = split(/,/, $arg->toString());
    for my $option (@options) {
      $option =~ s/^\s+|\s+$//g; # remove both leading and trailing spaces
      my $val;
      if ($option =~ /^(.*)=(.*)$/) {
        # Options of the form 'option=key' (e.g. 'visible anchor points=false')
        $1 =~ s/^\s+|\s+$//g;
        $2 =~ s/^\s+|\s+$//g;
        ($option, $val) = ($1, $2);
      } else {
        # Options of the form 'option' (e.g. 'notion')
        $val = 1;
      }
      if (!$processConfigure{$option}) {
        Warn("unexpected", $option, $stomach,"Unknown option '$option' for package knowledge."); 
      }
      rememberOption($option, $val);
      $processConfigure{$option}($val);
    }
    return undef;
});

# Writing mode

for my $option ("paper", "electronic", "composition") {
  DeclareOption($option, sub {
    AssignValue($klOption . $option => 1, 'global');
    Info("Todo: option $option");
  });
}

# Other packages

for my $package ("hyperref", "xcolor", "cleveref") {
  DeclareOption($package, sub {
    RequirePackage($package);
    AssignValue($klOption . $package => 1, 'global');
  });
}

for my $package ("makeidx", "imakeidx") {
  DeclareOption($package, sub {
    RequirePackage($package);
    Info("Todo: option $package");
    AssignValue($klOption . $package => 1, 'global');
  });
}

# Configuration option

for my $option ("quotation", "notion", "latexmlverbose") {
  DeclareOption($option, sub {
    rememberOption($option, 1);
    $processConfigure{$option}();
  });
}

ProcessOptions();

# ---
# Defines functions to handle all knowledges
# ---

sub processDirectives {
  # Given a pair (key, value) defining a new directive, updates the hashref
  # $refDirectives accordingly.
  my ($key, $value, $refDirectives) = @_;
  my $processDirectives_ = {
    synonym => sub { $refDirectives->{"link"} = LookupValue($lastKnowledge); },
    default => sub {
      # Remove surronding double braces in value (if there are some)
      $refDirectives->{$key} = ($value =~ /^{(.*)}$/) ? $1 : $value;
    }
  };
  ($processDirectives_->{$key} || $processDirectives_->{"default"})->();
}

sub breakupDirectives {
	my ($directivesString) = @_;
	# $directives is a string, containing a list of directives
	# of the form `key=value` (e.g. `url={https://wikipedia.org}`)
	# or of the form `key` (e.g. `notion`, `synonym`).
	# We break it into a hashable.
	my %directivesHash;
	foreach my $dir (split(",", $directivesString)) {
		if ($dir =~ /^(.*)=(.*)$/) {
      processDirectives($1, $2, \%directivesHash);
		} else {
      processDirectives($dir, 1, \%directivesHash);
    }
	}
	return \%directivesHash;
}

sub isKnowledgeDefined {
  my ($kl) = @_;
  return defined LookupMapping($definedKnowledges, $kl);
}

sub getDirective {
  # Checks if the a directive was given for a knowledge.
  # Returns either a boolean or a value (e.g. for `url`).
  my ($kl, $dir) = @_;
  if (isKnowledgeDefined($kl) && defined LookupMapping($definedKnowledges, $kl)->{$dir}) {
    return LookupMapping($definedKnowledges, $kl)->{$dir};
  }
  return 0; 
}

sub getRootNotion {
  # Given a knowledge, get its root knowledge (obtain by following the link directive),
  # or 0 if it doesn't exist.
  my ($kl) = @_;
  my @visitedKls = ();
  while (!getDirective($kl, "notion")) {
    if (first {$_ eq $kl} @visitedKls) {
      Warn('misdefined', $kl, undef, "Circular knowledge definition for '$kl'.");
      return 0;
    }
    push(@visitedKls, $kl);
    if (my $parent = getDirective($kl, "link")) {
      $kl = $parent;
    } else {
      return 0;
    }
  }
  return $kl;
}

sub getUrl {
  # Given a knowledge, returns its url if it has some, and zero otherwise.
  my ($kl) = @_;
  if (my $url = getDirective($kl, "url")) {
    return $url;
  }
  return 0;
}

# ---
# Parameters types (argument readers)
# ---

# Read a parenthesis delimited argument.
# This DOES balance () within the argument, contrary to the ill-named `BalancedParen`.
DefParameterType('TrulyBalancedParen',
  sub {
    my ($gullet) = @_;
    return undef unless $gullet->ifNext(T_OTHER('('));
    $gullet->readToken();  # consume opening '('
    my @tokens = ();
    my $depth = 1;
    while ($depth > 0) {
      my $token = $gullet->readToken();
      if (!defined $token) {
        Error('expected', ')', $gullet, "Missing closing parenthesis");
      }
      if ($token->toString() eq '(') {
        $depth++;
        push(@tokens, $token);
      }
      elsif ($token->toString() eq ')') {
        $depth--;
        push(@tokens, $token) if $depth > 0;  # Don't include final ')'
      }
      else {
        push(@tokens, $token);
      }
    }
    return Tokens(@tokens);
  },
  reversion => sub {
    my ($arg) = @_;
    return ($arg ? (T_OTHER('('), $arg->revert, T_OTHER(')')) : ());
  }
);

# ---
# Defines primitives and constructors
# ---

sub readPipeKl {
  my ($gullet) = @_;
  my @tokens = ();
  my $tok = $gullet->readToken();
  while (ref $tok && $tok->toString() ne "\n") {
    push(@tokens, $tok);
    $tok = $gullet->readToken();
  }
  my $klStr = ToString(Tokens(@tokens));
  $klStr =~ s/^\s+|\s+$//g; # removes leading and trailing whitespaces
  return $klStr;
}

# Store the directives in a global dict called $definedKnowledges
# DefPrimitive('\knowledge{}{}',
#   sub {
#     my ($stomach, $source, $directives) = @_;
#     AssignMapping($definedKnowledges, $source->toString(), breakupDirectives($directives->toString()));
#     AssignValue($lastKnowledge, $source->toString());
#     return undef;
# });
DefPrimitive('\knowledge{}',
  sub {
    my ($stomach, $arg1) = @_;
    my $gullet = $stomach->getGullet();
    $gullet->skipSpaces();
    if ($gullet->ifNext(T_BEGIN())) {
      # Syntax: \knowledge{kl}{directives}
      my $kl = $arg1;
      my $directives = $gullet->readArg();
      AssignMapping($definedKnowledges, $kl->toString(), breakupDirectives($directives->toString()));
      AssignValue($lastKnowledge, $kl->toString());
    } elsif ($gullet->ifNext(T_OTHER("|"))) {
      # Syntax: \knowledge{directives} \n | kl1 \n | kl2 \n | kl3 \n
      my $directivesHash = breakupDirectives($arg1->toString());
      my $firstKl = undef;
      while ($gullet->ifNext(T_OTHER("|"))) {
        $gullet->readToken();
        my $kl = readPipeKl($gullet);
        if ($firstKl) {
          $directivesHash = {link => $firstKl};
        } else {
          $firstKl = $kl;
          AssignValue($lastKnowledge, $kl);
        }
        AssignMapping($definedKnowledges, $kl, $directivesHash);
        $gullet->skipSpaces();
      }
    } else {
      Error('expected', '{} or |', $stomach, "\\knowledge expects either {directives} or | after first argument.")
    }
    return undef;
});

# Labels of the anchor will be added when constructing \intro.
DefConstructor('\AP',
  sub {
    my $document = $_[0];
    unless (LookupValue($APindex)) {
      AssignValue($APindex, 0);
    }
    my $APindexValue = LookupValue($APindex);
    AssignValue($APindex, $APindexValue + 1);
    $document->openElement("ltx:anchor", class => "klAP", labels => "klAP:" . $APindexValue);
    AssignValue($lastAP, $document->getNode());
    $document->closeElement("ltx:anchor");
  },
  afterConstruct => sub {
    my $document = $_[0];
  }
);

# Sectioning commands introduce \AP
for my $cmd ('\part', '\chapter', '\section', '\subsection', '\subsubsection', '\paragraph', '\subparagraph') {
  my $oldcmd = $cmd . 'KLold';
  Let($oldcmd, $cmd);
  DefMacro(($cmd . ' OptionalMatch:* []{}'), sub {
    my ($gullet, $star, $short, $title) = @_;
    if ($star) {
      return Tokens(T_CS($oldcmd), T_OTHER('*'), T_BEGIN, T_CS('\AP'), $title->unlist, T_END);
    }
    if ($short) {
      return Tokens(T_CS($oldcmd), T_OTHER('['), $short->unlist, T_OTHER(']'), T_BEGIN, T_CS('\AP'), $title->unlist, T_END);
    } 
    return Tokens(T_CS($oldcmd), T_BEGIN, T_CS('\AP'), $title->unlist, T_END);
  });
}

sub parse_kl_or_intro {
  my ($document, $scope, $kl, $text) = @_;
  $kl = ($kl ? $kl->toString() : $text->toString()) . ($scope && ($scope->toString() ne '') ? '@' . $scope->toString() : '');
  (kl => $kl, text => $text->toString())
}

DefConstructor('\kl OptionalTrulyBalancedParen []{}',
  sub {
    my $document = $_[0];
    my %props = parse_kl_or_intro(@_);
    my $kl = $props{"kl"};
    my $text = $props{"text"};
    my %args = ();
    OptionalNote("\\kl: $kl");
    if (my $rootkl = getRootNotion($kl)) {
      %args = ("labelref" => $prefixLabel . $rootkl, class => "kl");
      OptionalNote("\tpoint to: $rootkl");
    } elsif (my $url = getUrl($kl)) {
      %args = ("href" => $url, class => "kl");
      OptionalNote("\turl: $url");
    } else {
      %args = (class => "klundefined");
      OptionalNote("\tundefined");
    }
    $document->openElement("ltx:ref", %args);
    $document->absorb($text);
    $document->closeElement("ltx:ref");
  }
);

sub getLastAP {
  my ($document) = @_;
  # If some AP has already been defined, we return it.
  # Otherwise, we look for the last tag with a `xml:id` attribute.
  # Typically this should correspond to the parent paragraph.
  if (my $anchor = LookupValue($lastAP)) {
    return $anchor;
  } else {
    AssignValue($lastAPsubstitute, $document->documentElement());
    sub dfs {
      my ($node) = @_;
      if ($node->hasAttribute('labels')) {
        AssignValue($lastAPsubstitute, $node);
      }
      for my $child ($node->getChildrenByTagName('*')) {
        dfs($child);
      }
    }
    dfs($document->documentElement());
    return LookupValue($lastAPsubstitute);
  }
}

# There was no reasonable element for \intro that supported the attribute labels,
# so we added this attribute to the anchor element.
# https://math.nist.gov/~BMiller/LaTeXML/manual/schema/LaTeXML-common/#I1.ix14.I14.ix2.p1
DefConstructor('\intro OptionalTrulyBalancedParen []{}',
  sub {
    my ($document, $scope, $kl, $text) = @_;
    my %props = parse_kl_or_intro(@_);
    my $labelref = $prefixLabel . ($props{"kl"});
    $text = $props{"text"};
    my $class;
    OptionalNote("\\intro: $text");
    if (isKnowledgeDefined($props{"kl"})) {
      # Move labels to the last anchor
      my $anchor = getLastAP($document);
      # We only append the new label if the anchor has an xml:id
      # This prevent e.g. adding a labels attribute to a tag that shouldn't have one.
      if ($anchor->hasAttribute('labels')) {
        my $newLabel = $anchor->getAttribute("labels") . " ";
        $newLabel .= $prefixLabel . getRootNotion($props{"kl"});
        $anchor->setAttribute("labels", $newLabel);
        OptionalNote("\tlabel moved to: " . $anchor->nodeName);
      } else {
        Warn('ignore', $props{'kl'}, $document->getNode(), "Intro of knowledge `$props{'kl'}` is ignored, there is no preceeding anchor point (\\AP).");
      }
      $class = "klintro";
    } else {
      $class = "klintroundefined";
      OptionalNote("\tundefined");
    }
    $document->openElement("ltx:text", labels => $labelref, class => $class);
    $document->absorb($text);
    $document->closeElement("ltx:text");
  }
);

# ---
# Quotation option
# ---

# Given a knowledge in quotation mode (`text`, `text@kl` or `text@kl@scope`)
# represented by a sequence of tokens, returns a reference to an array (text, kl, scope), where
# each element is again a sequence of tokens.
sub parse_knowledge_quotation {
  my @inputTokens = @_;
  my $parsedInput = [[], [], []];
  my $nbAt = 0;
  for my $tok (@inputTokens) {
    if ($tok->toString eq '@' && $nbAt < 2) {
      $nbAt++;
    } else {
		  push @{$parsedInput->[$nbAt]}, $tok;
    }
  }
  return $parsedInput;
}

# Transforms a sequence of tokens representing `text@kl@scope``
# into a sequence of tokens representing `(scope)[kl]{text}`.
# Empty args are ignored, so for instance `text` yields `{text}`
# rather than `()[]{text}`.
sub token_sequence_from_quotation_knowledge {
  my $parsedInput = parse_knowledge_quotation(@_);
  my @outputTokens = ();
  my $delims = [[T_OTHER('('), T_OTHER(')')], [T_OTHER('['), T_OTHER(']')], [T_BEGIN(), T_END()]];
  for my $i (0,1,2) {
    if (@{$parsedInput->[2-$i]}) {
      push(@outputTokens, $delims->[$i][0]);
      push(@outputTokens, @{$parsedInput->[2-$i]});
      push(@outputTokens, $delims->[$i][1]);
    }
  }
  return @outputTokens;
}

DefMacro('"', sub {
  my ($gullet) = @_;
  my @readTokens = ();
  my $tok = $gullet->readToken();
  # Check next character to check if it is also a quote
  my $in_double_quote = 0;
  if (ref $tok && $tok->toString() eq '"') {
    $in_double_quote = 1;
  } else {
    $gullet->unread($tok);
  }
  while (1) {
    $tok = $gullet->readToken();
    if (ref $tok && $tok->toString() ne '"') {
      push(@readTokens, $tok);
    } else {
      last;
    }
  }
  # If the sequence started with two doubles quotes, looks for the second double quote. 
  if (ref $tok && $tok->toString() eq '"' && $in_double_quote) {
    $tok = $gullet->readToken();
  }
  unless (ref $tok && $tok->toString() eq '"') {
    Note("Error");
    return ()
  }
  # my $parsedKl = parse_knowledge_quotation(@readTokens);
  # print_list_tokens(@readTokens);
  # print "\tScope: "; print_list_tokens(@{$parsedKl->[2]});
  # print "\tKl: "; print_list_tokens(@{$parsedKl->[1]});
  # print "\tText: "; print_list_tokens(@{$parsedKl->[0]});
  return (
    T_CS($in_double_quote ? '\intro' : '\kl'),
    token_sequence_from_quotation_knowledge(@readTokens)
  );
});

1; 